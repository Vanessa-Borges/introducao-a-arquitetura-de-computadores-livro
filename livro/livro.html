<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="pt-BR">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.6" />
<meta name="description" content="Livro de Introdução à Arquitetura de Computadores" />
<meta name="keywords" content="Computação" />
<title>Introdução a Arquitetura de Computadores</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Introdução a Arquitetura de Computadores</h1>
<span id="author">Alisson Vasconcelos de Brito</span><br />
</div>
<div id="content">
<div class="sect1">
<h2 id="prefacio">Prefácio</h2>
<div class="sectionbody">
<div class="paragraph"><p>texto</p></div>
<div class="sect2">
<h3 id="_público_alvo">Público alvo</h3>
<div class="paragraph"><p>estudantes</p></div>
</div>
<div class="sect2">
<h3 id="_método_de_elaboração">Método de Elaboração</h3>
<div class="paragraph"><p>Financiamento da capes.</p></div>
</div>
<div class="sect2">
<h3 id="_contribuição">Contribuição</h3>
<div class="paragraph"><p>Erros e etc.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introdução">Introdução</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="title">Objetivos do capítulo</div>
<div class="content">
<div class="paragraph"><p>Ao final deste capítulo você deverá ser capaz de:</p></div>
<div class="ulist"><ul>
<li>
<p>
Definir o que é a Arquitetura de Computadores e sua relevância
</p>
</li>
<li>
<p>
Apresentar a Arquitetura Geral de um computador e suas principais operações
</p>
</li>
<li>
<p>
Diferencias sistemas digitais de analógicos
</p>
</li>
<li>
<p>
Apresentar o funcionamento de um transistor e sua relevância para a industria de dispositivos digitais
</p>
</li>
<li>
<p>
Destacar a Lei de Moore e seu impacto para a evolução da industria de dispositivos eletrônicos digitais
</p>
</li>
<li>
<p>
Identificar os principais fatos da evolução dos computadores
</p>
</li>
</ul></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Você sabe o que é Arquitetura de computadores? Você já se perguntou porque precisa estudar Arquitetura de Computadores? Esse capítulo nós vamos aprender que essa é uma das principais disciplinas da Ciência da Computação. Não só isso, foi a Arquitetura de Computadores que permitiu que a humanidade avançasse em todos os aspectos da ciência, saúde e tecnologia. Ao final desse capítulo, espero que você concorde comigo.</p></div>
<div class="sect2">
<h3 id="_o_que_é_a_arquitetura_de_um_computador">O que é a Arquitetura de um Computador?</h3>
<div class="paragraph"><p>O termo arquitetura é principalmente utilizado na construção e decoração de edificações. Ele diz respeito à forma e a estrutura de uma construção. O termo refere-se à arte ou a técnica de projetar e edificar o ambiente habitado pelo ser humano. Na computação o termo foi adaptado para denominar a técnica (talvez até a arte também) de projetar e construir computadores. Nesse livro você não vai aprender a construir seu próprio computador. Para isso eu recomendo outros autores, John L. Hennessy, David A. Patterson e Andrew S. Tanenbaum. Esses autores produzem livros para engenheiros de computadores e acompanhá-los antes de se tornar um pode ser uma tarefa bastante árdua. Aqui você vai conhecer o computador por dentro e saber como ele funciona. Você não será capaz de construir um computador, mas saberá o suficiente para entender como os programas funcionam e até porque o computador para de funcionar as vezes, ou funciona lentamente, e que nessas situações, pressionar teclas do teclado rapidamente, ao mesmo tempo que move o mouse aleatoriamente, não faz o computador voltar a trabalhar novamente.</p></div>
</div>
<div class="sect2">
<h3 id="_por_que_estudar_arquitetura_de_computadores">Por que estudar Arquitetura de Computadores?</h3>
<div class="paragraph"><p>É essencial que todos profissionais da Computação tenham pelo menos conhecimentos básicos de Arquitetura de Computadores. Saber como o computador funciona nos permitirá entender sua capacidade (e incapacidade) de resolver problemas, sobre como programá-los da melhor forma possível, como deixar o computador e os dados contidos neles mais seguros, como ganhar desempenho e o que faz ele ficar tão lento às vezes a ponto de querermos destrui-lo.
Então, estudar Arquitetura de Computadores é tão importante para um profissional de Computação, como estudar Anatomia é importante para um médico. Antes de iniciar qualquer estudo na Medicina, um médico precisa saber em detalhes o funcionamento do corpo humano. Quais são seus órgãos, como eles trabalham individualmente e como se relacionam para formar um sistema (digestivo, respiratório, motor etc.). Com a Arquitetura de Computadores é semelhante. Vamos aprender quais são os componentes de um computador, como eles funcionam e como eles trabalham em conjunto formando um sistema.
Sem dúvidas o ser humano é a máquina mais perfeita já criada, mas vamos ver que o Computador é uma das máquinas mais incríveis que o homem já criou.</p></div>
</div>
<div class="sect2">
<h3 id="_um_aluno_de_licenciatura_em_computação_precisa_estudar_arquitetura_de_computadores">Um aluno de Licenciatura em Computação precisa estudar Arquitetura de Computadores?</h3>
<div class="paragraph"><p>Ao longo de minha experiência como professor de Arquitetura de Computadores para alunos de Licenciatura em Computação, eu sempre ouvi essa pergunta. ``Por que precisamos estudar Arquitetura de Computadores?”. Espero que isso já esteja claro para você. Mas se ainda não estiver, aqui vai uma outra razão. Você será um licenciado e vai trabalhar no ensino e aprendizagem da Ciência da Computação. Como ensinar alguém sobre essa ciência se você não souber em detalhes como um computador funciona? Isso seria como um professor de Farmácia que não conhece bem a Química, ou um professor de Matemática que não conhece os números.</p></div>
</div>
<div class="sect2">
<h3 id="_arquitetura_geral">Arquitetura geral</h3>
<div class="paragraph"><p>Hoje em dia há muitos tipos de computadores e diversas arquiteturas. Elas são frutos de muitos estudos, pesquisas e avanços tecnológicos. Mas todos computadores compartilham uma arquitetura comum. Essa arquitetura é o que separa um computador de uma calculadora de bolso, de um aparelho de televisão ou um relógio de pulso. Essa arquitetura é apresentada na <a href="#fig_arquitetura">[fig_arquitetura]</a>.</p></div>
<div class="imageblock" id="fig_arquitetura">
<div class="content">
<img src="images/fig_arquitetura.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 1. Arquitetura básica de um computador</div>
</div>
<div class="paragraph"><p>Todo computador possui uma Unidade Central de Processamento, ou, do inglês, <strong>Central Processing Unit</strong> (CPU) e uma Memória Principal. Todos os dados a serem processados pela CPU, para operações lógicas e aritméticas, precisam estar na memória. Da memória os dados são transferidos para a CPU através de fios paralelos de comunicação, chamados de Barramento de Dados. Entretando, a CPU não toma decisões por si própria. Ela não sabe que dados deve trazer da memória, muito menos que operação executar com eles. Para isso, ela precisa que instruções, também armazenadas na memória, sejam trazidas para a CPU através do Barramento de Endereço. Cada instrução informa para a CPU que operação ela deve executar, com quais dados e o que ela deve fazer com o resultado da operação.</p></div>
<div class="paragraph"><p>Para poder se localizar, a memória é organizada em endereços. Todos os dados e as instruções são localizadas através desses endereços. Cada instrução indica para a CPU que dados devem ser transferidos e processados através dos endereços desses dados. Esse endereço é transferido para a memória pela CPU através do Barramento de Endereço. A memória localiza o tal dado e o transfere para a CPU via Barramento de Dados. As instruções são desenvolvidas pelo programador, através de linguagens de programação. As ferramentas de compilação transformam os programas escritos em linguagens de alto nível, como C, Java e Phython, em instruções de máquina, que são finalmente copiadas para a memória no momento em que precisam ser executadas. Cada instrução é armazenada em um endereço diferente da memória. Na execução normal, a CPU passa para a memória, via Barramento de Endereço, o endereço da primeira instrução do programa, a memória transfere a instrução pelo Barramento de Instrução, a CPU a executa e, em seguida, solicita a instrução do endereço seguinte. Assim, os programas são executados sempre de forma sequencial, a não ser que uma instrução especial solicite que ela salte para uma instrução que não seja a consecutiva. Isso é o caso quando há instruções condicionais (como o ``se” ou ``if”), instruções de repetição (como ``while” e o ``for”), ou chamadas a sub-programas, ou mesmo, por ordem do Sistema Operacional, para que o programa pare de executar para que um outro tome seu lugar.</p></div>
<div class="paragraph"><p>As memórias são, quase sempre, muito mais lentas do que as CPUs. Isso exigiu, ao longo dos anos, que as CPUs possuíssem também uma porção interna de memória muito rápida, chamada Memória Cache. A tecnologia que permite essas memórias serem mais rápidas, tornam-as também muito caras. Por isso que sua capacidade geralmente é muito limitada. Para acelerar ainda mais, elas são instaladas dentro das CPUs. Todos os dados e instruções transferidos da Memória Principal para a CPU são salvos também na Cache. Como a Cache não é capaz de guardar todos os dados da Memória Principal, apenas os dados mais recentes transferidos para a CPU permanecem na Cache. Técnicas muito avançadas são aplicadas para que se consiga, no máximo possível, manter os dados mais importantes daquele instante na Memória Cache.</p></div>
<div class="paragraph"><p>A CPU também é responsável por enviar sinais de controle aos outros dispositivos do computador, como periféricos, dispositivos de entrada e saída, e memórias externas. Esse sinais são enviados quando uma instrução dá ordem para tal. Por exemplo, quando uma instrução pede que uma mensagem sem impressa na tela, a CPU, ao receber e executar essa instrução, envia para o controle do monitor que imprima na tela a mensagem contida o endereço que também foi passada pela instrução.</p></div>
<div class="paragraph"><p>É esse comportamento que diferencia um computador de outros dispositivos eletrônicos mais simples. A essência da CPU não é muito diferente de uma calculadora de bolso. Ela executa operações lógicas e aritméticas. Entretanto, no projeto do computador, o papel do homem foi substituído pela programação. Todas instruções das tarefas que a CPU precisa executar são armazenadas na memória e, a partir de então, a CPU pode trabalhar sem qualquer interferência externa. Com a programação, a CPU pode também executar tarefas diversas, desde simulações, jogos, tocar músicas e vídeos etc. Simplificando, o computador é uma máquina programável e de propósito geral.</p></div>
<div class="sect3">
<h4 id="_operações_básicas">Operações básicas</h4>
<div class="paragraph"><p>Todos computadores executam três operações básicas:
* Movimentação de dados
* Processamentos de dados
* Armazenamento de dados</p></div>
<div class="paragraph"><p>A movimentação de dados é a transferência de um dado de um ponto para outro do computador. Pode ser de um endereço de memória para outro, de um dispositivo de entrada para a memória, ou da memória para um dispositivo de saída. O processamento de dados ocorre quando a CPU recebe um determinado dado e executa uma operação que o modifica de alguma forma. Já as operações de armazenamento ocorre quando a CPU precisa registrar um dado em algum local específico, como salvar um dado no disco rígido, ou num pendrive, ou mesmo na Memória Principal.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_analógicos_x_sistemas_digitais">Sistemas Analógicos x Sistemas Digitais</h3>
<div class="paragraph"><p>Para sabermos a importância de um computador e sua forma de funcionamento, precisamos conhecer suas potencialidades e suas limitações. O computador é um dispositivo eletrônico digital. Isso significa que ele armazena, processa e gera dados na forma digital. Por outro lado, o computador não é capaz de processar dados analógicos. Eles antes precisam ser convertidos para digital para poderem ser utilizados por computadores. Mas o que venha a ser um dado analógico? Qualquer informação presente na natureza, como uma imagem, um som ou um cheiro, pode ser analisada em no mínimo duas componentes. Uma seria a sua intensidade e outra o tempo. A <a href="#fig_analog_digital">[fig_analog_digital]</a> a seguir apresenta essa representação, onde o sinal em forma de onda cinza seria a representação de um sinal analógico.</p></div>
<div class="imageblock" id="fig_analog_digital">
<div class="content">
<img src="images/fig2.png" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 2. Sinal Analógico versus Sinal Digital</div>
</div>
<div class="paragraph"><p>Um som, por exemplo, é formado por vibrações no ar de diferentes intensidades (amplitudes) ao longo do tempo. Cada amplitude vai soar para nossos ouvidos como um tom diferente e alguns são até imperceptíveis aos nossos ouvidos. Por outro lado, como o computador é um dispositivo baseado em números, para que ele armazene um som em sua memória e possa fazer qualquer processamento sobre ele (gravar, transmitir, mixar), ele deve antes representá-lo na forma de números. Ai que está a dificuldade. As intensidades possíveis de um som são tantas que se aproximariam do infinito. Para tornar essa grandeza mais clara, imagine que pudéssemos emitir a intensidade do som emitido por um pássaro. Se em terminado momento dissermos que essa intensidade tem valor 5. Logo em seguida um outro som é emitido, medidos e constatamos que sua intensidade é 4. Até aí tudo bem! Mas o pássaro poderá em seguida emitir diversos sons que estariam entre 4 e 5, como 4,23, ou 4,88938, ou até uma dízima periódica, como 4,6666… Um ser humano, mesmo que não consiga medir a intensidade do canto do pássaro, consegue ouvi-lo, apreciá-lo e até repeti-lo com uma certa proximidade com alguns assobios. Mas o computador não trabalha assim! Antes de tudo, um computador teria que discretizar esses valores medidos, ou seja, passá-los do domínio dos números reais para o domínio dos inteiros. Assim, o que era 4 permanece 4, o que era 5, continua como 5, mas o que foi medido como 4,23 é convertido para 4, e o que era 4,88938 e 4,666 são convertidos para 5. Dessa forma, o computador passa a tratar com números reais e finitos. Um canto de um pássaro (ou até de uma orquestra sinfônica) pode ser armazenado e processador pelo computador. Na <a href="#fig_analog_digital">[fig_analog_digital]</a> apresentada, a onda quadrada representa um sinal digital.</p></div>
<div class="paragraph"><p>Mas perceba que o som emitido pelo pássaro teve que ser modificado. Ele antes era complexo, rico e cheio de detalhes. Agora se tornou algo mais simples e reduzido. Houve uma perda de informação ao passarmos o dado do analógico para o digital. Processo semelhante ocorre quando outras informações da natureza são passadas para o computador, como uma imagem através de uma foto, ou uma cena através de um vídeo. Parte da informação deve ser ignorada para que possa ser armazenada em computadores. Você deve estar se perguntando então, quer dizer que imagens e sons analógicos possuem mais qualidade do que digitais? A resposta rigorosa para essa pergunta é, sim! Mas uma resposta mais consciente seria, as vezes! Isso porque a perda causada pela digitalização pode ser reduzida até níveis altíssimos que modo que nem o ouvido, nem a visão humana serão capazes de perceber.</p></div>
<div class="paragraph"><p>Como exemplo de dados analógicos podemos citar tudo o que vem da natureza, som, imagem, tato, cheiro, enquanto que digitais são todos aqueles armazenados por dispositivos eletrônicos digitais, como computadores, celulares e TVs (exceto as antigas analógicas). Se uma foto digital, por exemplo, possui menos qualidade do que uma analógica, por que todos procuram apenas máquinas fotográficas digitais, transformando as analógicas quase em peças de museu? A resposta está na praticidade. Os computadores só entendem informações digitais. Uma máquina fotográfica, mesmo com qualidade inferior, vai nos permitir passar as fotos para o computador, compartilhar com os amigos, aplicar edições e melhorias, ampliar e copiar quantas vezes quisermos. Tarefas que antes eram impossíveis com máquinas analógicas. O mesmo pode ser refletido para músicas, documentos e livros. O mundo hoje é analógico!</p></div>
</div>
<div class="sect2">
<h3 id="_o_transistor">O Transistor</h3>
<div class="paragraph"><p>O transistor é um componente eletrônico criado na década de 1950. Ele é o responsável pela revolução da eletrônica na década de 1960. Através dele foi possível desenvolver sistemas digitais extremamente pequenos. Todas funcionalidades de um computador são internamente executadas pela composição de milhões de transistores. Desde operações lógicas e aritméticas, até o armazenamento de dados em memórias (a exceção do disco rígido, CD, DVD e fitas magnéticas), tudo é feito pelos transistores.</p></div>
<div class="paragraph"><p>Os primeiros eram fabricados na escala de micrômetros 10<sup>-6</sup> metros). Daí surgiram os termos microeletrônica e micro-tecnologia. Depois disso deu-se início a uma corrida tecnológica para se desenvolver transistores cada vez mais rápidos, menores e mais baratos. Essa revolução dura até hoje, mas foi mais forte nas décadas de 1980 e 1990. Foi emocionante acompanhar a disputa entre as empresas norte-americadas Intel e AMD para dominar o mercado de computadores pessoais. A cada 6 meses um novo processador era lançado por um delas, tomando da concorrente a posição de processador mais rápido do mercado. Poucos eram aqueles consumidores que conseguiam se manter a atualizados com tantos lançamentos.</p></div>
<div class="paragraph"><p>O princípio básico é utilizar a eletrônica (corrente elétrica, resistência e tensão) para representar dados e depois poder executar operações com eles. A forma mais fácil de fazer isso foi primeiramente limitar os dados a apenas dois tipos. Zero e um. O sistema de numeração binário é muito mais fácil de representar com dispositivos eletrônicos do que o decimal, por exemplo. O transistor possui dois estados. Ou ele está carregado, ou está descarregado, assim como uma pilha. Isso facilmente pode ser mapeado para o bit 1 (carregado) e o bit (0). O revolucionário, diferente de uma pilha, foi possibilitar que esse estado pudesse ser mudado eletronicamente a qualquer momento e de forma muito rápida.

Assim, com 8 transistores em paralelo, eu posso representar, por exemplo um número de 8 bits. Posso mudar seus valores mudando suas cargas, e posso ler seus valores chegando se cada um possui, ou não carga. Esse é o princípio básico de construção de uma memória.</p></div>
<div class="paragraph"><p>De forma semelhante, é possível integrar transistores para que os mesmos executem operações lógicas e aritméticas. As portas lógicas estudadas por você em Introdução à Computação são todas fabricadas utilizando transistores.

Quanto menores são os transistores, mais dados podem ser armazenados por área. Ao mesmo tempo, transistores menores guardam menos carga. Isso torna mais rápido o processo de carregamento e descarregamento, que, por consequência, torna o processamento e armazenamento de dados muito mais rápidos também.

Com a evolução da nanoeletrônica, os transistores são tão pequenos que possibilitou a construção de memórias de 1GB (um giga byte) do tamanho da unha da mão de um adulto. Para ser ter uma ideia, 1 Giga é a abreviação de 10<sup>9</sup>, ou seja, um bilhão. Um byte são 8 bits. Então, uma memória de 1GB possui, pelo menos, 8 bilhões de transistores. Os processadores também se tornaram bastante velozes com a miniaturização dos transistores. Os processadores atuais trabalham na frequência de GHz (Giga Hertz), ou seja, na casa de bilhões de ciclos por segundo (diferente de operações por segundo). Isso é muito rápido!</p></div>
<div class="imageblock" id="fig_mosfet">
<div class="content">
<img src="images/fig1.png" alt="images/fig1.png" />
</div>
<div class="title">Figura 3. Estrutura de um transistor tipo MOSFET</div>
</div>
<div class="paragraph"><p>Na <a href="#fig_mosfet">[fig_mosfet]</a> anterior é apresentada a estrutura de um transistor MOSFET. Esse transistor é o mais utilizado para se construir sistemas eletrônicos digitais, como os computadores. O nome vem da abreviação de ``Metal-Oxide Semiconductor Field-Effect Transistor”. Vamos ver o que significa cada palavra dessas, e isso nos ajudará a conhecer um pouco mais o MOSFET e sua relevância. O termo MOS (``Metal-Oxide Semiconductor”) vem dos materiais utilizados para compor um MOSFET, que são principalmente, óxido metálico e semicondutor.</p></div>
<div class="paragraph"><p>Semicondutores são materiais que possuem propriedades que nem os permitem classificar como condutor, nem como isolante. Em algumas condições ele age como um isolante, e em outras, como um condutor. O semicondutor mais utilizado em transistores é o silício (símbolo Si na Tabela Periódica). Em condições ambientes, o silício age como um isolante, mas se misturado a outros materiais, ele pode se tornar um condutor até a intensidade desejada.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">O Silício se tornou tão importante que modificou toda uma região da Califórnia nos Estados Unidos na década de 1950, tornando-a uma das mais promissoras do mundo até hoje. Essa região abrigou e abriga as mais importantes empresas do ramo de projeto de computadores, como Intel, AMD, Dell, IBM e Apple, e depois de softwares que iriam executar nesses computadores, como Microsoft, Oracle e Google. Essa região é chamada de Vale do Silício.</td>
</tr></table>
</div>
<div class="paragraph"><p>No transistor da <a href="#fig_mosfet">[fig_mosfet]</a> a cor verde representa um cristal de silício que foi dopado com cargas negativas. Já a cor vermelha, representa a parte que foi dopada com cargas positivas. Na situação normal uma corrente elétrica aplicada no Dreno (Drain) consegue produz percorrer o estreito canal negativo e seguir até a Fonte (Source). Nessa condição dizemos que o transistor está ativo. Porém, for aplicada uma tensão negativa na Porta (Gate), as cargas positivas da região P (em vermelho) serão atraídas para mais próximo da Porta, e isso irá fechar o canal por onde passava a corrente elétrica. Nesse caso, dizemos que o transistor está inativo.</p></div>
<div class="paragraph"><p>Por que isso tudo nos interessa? Quando o transistor está ativo, ele pode ser visto com o valor 1, e quando inativo, ele pode ser visto com o valor 0. Assim, temos a menor memória possível de ser construída. Quando quisermos que ela guarde o valor 1, basta desligar a tensão da Porta e aplicar uma corrente no Dreno. Já quando quisermos que ele armazene o valor 0, precisamos aplicar uma corrente na Porta e fechar o canal. Então, a memória de 8 bilhões de bits, pode ser elaborada com 8 bilhões de transistores como esses.</p></div>
<div class="paragraph"><p>Agora conhecemos o primeiro aspecto que faz dos transistores essenciais para o entendimento do computador. Eles são usados para a construção de memórias. Memórias feitas a base de transistores são chamadas também de Memórias de Estado Sólido. Mas há outras, não tão eficientes e miniaturizadas, como memórias ópticas e magnéticas. O importante percebermos é que quanto menores pudermos construir esses transistores, melhor. O processo de abertura e fechamento do canal não é instantâneo. Ele leva um curtíssimo tempo, mas quando somados os tempos de todos os bilhões de transistores, ele passa a se tornar relevante. Quanto menor ele for, mais estreito é o canal e, portanto, mais rápido ele liga e desliga, da mesma forma, menor será a distância entre o Dreno e a Fonte, levando também menos tempo para os elétrons deixarem o Dreno em direção à fonte. Isso tudo fará a memória mais rápida. Transistores pequenos também possibilitam que mais dados sejam armazenados por área. É por isso que hoje enormes capacidades de armazenamento são disponíveis em dispositivos tão reduzidos, como são os exemplos de pen-drives e cartões de memória.</p></div>
<div class="paragraph"><p>Os transistores também são usados para executar operações lógicas e aritméticas. A carga retirada de um transistor pode servir para alimentar um outro e que, se combinados de forma correta, podem executar as operações lógicas básicas, E, OU, NÃO e as aritméticas, adição, subtração, divisão e multiplicação. Com isso, os transistores não apenas podem ser utilizados para armazenar dados, mas como executar operações lógicas e aritméticas sobre esses dados. Isso é fantástico e vem revolucionado todo o mundo. Não só na Ciência da Computação, mas como também em todas áreas do conhecimento. O que seria da humanidade hoje sem o computador? Sem o telefone celular? Sem os satélites?</p></div>
</div>
<div class="sect2">
<h3 id="_a_lei_de_moore">A Lei de Moore</h3>
<div class="paragraph"><p>Durante os anos de 1950 e 1965, a industrias do Vale do Silício disputavam pelo domínio do recém-surgido mercado da computação e eletrônica. Naquela época ainda não havia surgido o termo TIC (Tecnologia da Informação e Comunicação), mas ele seria mais apropriado para definir o nicho de clientes e serviços que eles disputavam. Eles dominavam a produção de circuitos eletrônicos digitais, dominados pela Intel e AMD, a produção de computadores e equipamentos de comunicação, como a Dell, Apple, IBM, HP e CISCO, além da indústria e software e serviços, como a Apple, Microsoft e, mais tarde, a Google. A disputa era grande e nem sempre leal.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">Assista ao filme “Piratas do Vale do Silício” (1999) e tenha uma ideia de como essa guerra estava longe de ser limpa.</td>
</tr></table>
</div>
<div class="paragraph"><p>Entretanto, não se sabia naquela época onde essa disputa ia parar, nem quem seriam os vencedores, nem mesmo, se haveria sequer vencedores. Até um dos sócios e presidente da Intel, Gordon Moore,  lançou um trabalho minucioso onde ele destacava a experiência que ele adquiriu ao longe de alguns anos trabalhando na indústria de fabricação de processadores e circuitos para computadores. Ele percebeu que, sempre a indústria avançava em sua tecnologia e conseguia reduzir o tamanho de cada transistor de um circuito integrado, os computadores tornavam-se também muito mais velozes do que antes. Porém, essa redução no tamanho dos transistores requer uma total atualização nos equipamentos da indústria, tornando os equipamentos anteriores obsoletos. Assim, só seria viável a evolução para transistores menores se o lucro da empresa fosse o suficiente para pagar todas essas despesas. Por outro lado, ele também percebeu que os computadores e equipamentos mais obsoletos ainda possuíam mercado aberto em países menos desenvolvidos economicamente. Ele concluiu então que a indústria seria sim capaz de continuar evoluindo na redução do tamanho dos transistores porque os novos computadores, sendo tornando mais velozes, seriam tão mais eficientes e atrativos, que todos os clientes, principalmente as empresas, fariam de tudo para trocar seus computadores antigos por novos, afim de se tornarem cada vez mais produtivos.</p></div>
<div class="paragraph"><p>Além dessa análise de mercado, ele analisou como o processo industrial era concebido e como os novos computadores se beneficiariam da redução do tamanho dos transistores. Ao final, ele afirmou que “A cada ano a quantidade de transistores por chip irá dobrar de tamanho, sem alteração em seu preço”. Essa frase pode ser interpretada também pelas consequências da quantidade de transistores por chip. Ou seja, a cada ano, com o dobro dos transistores, os chips se tornarão duas vezes mais rápidos. Um exemplo mais comum de chip são os processadores dos computadores. Então, por consequência, os computadores irão dobrar sua velocidade de processamento a cada ano, e ainda vão permanecer com o mesmo preço.</p></div>
<div class="paragraph"><p>Naquela época essa era uma afirmação muito forte e ambiciosa. Muitos receberam esse estudo com cautela. Mas não demorou muito para todos perceberem que as previsões de Moore estavam se realizando. Foi tanto, e o trabalho dele foi depois chamado de “Lei de Moore” e ela ainda é válida até os dias de hoje. Na <a href="#fig_moore">[fig_moore]</a> a seguir é possível perceber como a quantidade de transistores por processadores cresceu dos anos 1970 até por volta de 2003 (linha contínua). É possível ver que ela não se afastou muito das previsões de Moore (linha tracejada).</p></div>
<div class="imageblock" id="fig_moore">
<div class="content">
<img src="images/fig_moore.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 4. Evolução do número de transistores nos processadores em comparação com a Lei de Moore</div>
</div>
<div class="paragraph"><p>A Lei de Moore se tornou tão importante que ela não é usada apenas como uma meta a ser buscada e batida a cada ano, mas também como um meio para se verificar se a indústria está evoluindo na velocidade esperada. Apesar de Moore está muito correto em suas previsões, todos sabem, inclusive ele próprio, que esse crescimento não vai durar para sempre. Os transistores hoje estão na escala de 25 nanometros. Essa é a mesma escala de alguns vírus e bactérias. Reduzir mais do que isso está se tornando cada vez mais difícil. Pesquisadores e cientistas buscam outras formas de fazer com que os computadores continuem evoluindo em sua velocidade e reduzindo seu tamanho. Alguns pensam na substituição de transistores de Silício por outros materiais, como Grafeno. Outros até são mais radicais e defendem que a forma de computação deve mudar, talvez através de Computadores Quânticos ou de Bio-Computadores.</p></div>
<div class="paragraph"><p>Quanto menores forem os transistores, mais rapidamente eles podem ser carregados e descarregados. Isso possibilita que o sistema trabalhe cada vez mais veloz. Mas há ainda outra limitação para a redução do tamanho dos transistores é a dissipação de calor. Quanto menores os transistores, mais deles são adicionados num mesmo circuito. O funcionamento dos transistores, como dito anteriormente, é feito através da passagem de corrente elétrica (elétrons em movimento). Como toda máquina elétrica, nem toda corrente é aproveitada. Muito dela é desperdiçada através da dissipação de calor. Então, uma vez que há milhões desses transistores trabalhando juntos, a dissipação de calor é ainda maior.</p></div>
<div class="paragraph"><p>É muito importante para toda a humanidade que os computadores continuem evoluindo. A redução do tamanho dos computadores, aliada ao aumento de desempenho e sem o crescimento dos preços, permitiu que todas as ciência evoluíssem ao mesmo tempo, com a mesma velocidade. A metereologia, a medicina, as engenharias e até as Ciências Humanas avançaram sempre em conjunto com o avanço da computação. Para se ter um exemplo, foi a evolução dos transistores que permitiu que computadores se comunicassem numa velocidade tão grande que permitiu a formação da rede mundial de computadores, a Internet. Qualquer pessoa hoje consegue em poucos milissegundos fazer uma pesquisa por informações que estão do outro lado do planeta. Algo que antes só era possível viajando até bibliotecas distantes e cheirando bastante mofo e poeira. Hoje, ter em casa bilhões de bytes (Giga bytes) armazenados num minúsculo cartão de memória, é algo corriqueiro. A informação está hoje disponível numa escala tão grande e numa velocidade tão intensa que parece que mais nada é impossível para a humanidade. Após a Revolução Industrial do século XVIII que substitui os trabalhadores braçais por máquinas, o século XX, puxado pela evolução dos transistores, passou pelo o que muitos consideram a Revolução da Informação e o século XXI, já é considerado a “Era do Conhecimento”.</p></div>
</div>
<div class="sect2">
<h3 id="_a_evolução_dos_computadores">A evolução dos computadores</h3>
<div class="sect3">
<h4 id="_o_eniac">O ENIAC</h4>
<div class="paragraph"><p>O primeiro computador criado foi o ENIAC (‘Electronic Numerical Integrator And Computer’), desenvolvido por Eckert e Mauchly na Universidade da Pennsylvania, Estados Unidos. O projeto iniciou em 1943 financiado pelo governo americano. O período era da Segunda Guerra Mundial e o objetivo era poder calcular de forma mais ágil as melhores trajetórias para transporte de armas e mantimentos em meio aos exércitos inimigos. Esse é o tipo de cálculo que pequenos aparelhos celulares fazem hoje para encontrar rotas nas cidades através de GPS (‘Global Positioning System’) e análise de mapa. O projeto só foi concluído em 1946, tarde demais para ser utilizado para a Segunda Guerra, mas foi bastante utilizado até 1955.</p></div>
<div class="paragraph"><p>O ENIAC ocupava uma área de 4500 metros quadrados, pesava 30 toneladas e consumia cerca de 140KW. Ele era capaz calcular 5000 somas por segundo. A programação era feita manualmente através da manipulação de chaves, ou seja, não havia linguagem de programação, nem compiladores ou interpretadores de comandos. O Sistema Operacional só surgiu bem depois e tomou o emprego de muitos funcionários chamados na época de operadores de computadores. Profissão hoje extinta! O ENIAC ainda não utilizada transistores, mas válvulas que, dependendo de seu nível de carga, representavam um número. Cada válvula precisava estar devidamente aquecida para funcionar corretamente, então o processo de ligar o ENIAC era trabalhoso e levava bastante tempo. Ele trabalhava com o sistema de numeração decimal, o que parecia óbvio naquela época, mas que depois dos transistores, se tornaram complexo demais e foi adotado o sistema binário.</p></div>
<div class="paragraph"><p>Após a Segunda Guerra iniciou-se o período chamado de Guerra Fria, quando a espionagem, sabotagem e muito especulação reinava entre os países liderados pela União Sovitética e Estados Unidos. Prato cheio para os computadores. Possuir um computador que fosse capaz de decifrar mensagens codificadas dos inimigos era o sonho de consumo de todo general daquela época.</p></div>
</div>
<div class="sect3">
<h4 id="_a_arquitetura_de_von_neumann">A Arquitetura de von Neumann</h4>
<div class="paragraph"><p>Muitas empresas e governos corriam para construir seu próprio computador que fosse mais avançado do que os anteriores. Muitos projetos surgiram depois do ENIAC. Mas todos eles eram barrados por algumas dificuldades e limitações. Como por exemplo, o fato de não serem programados e trabalharem com números decimais. O problema de trabalhar com decimais é que cada algarismo armazenado possui 10 estados possíveis, representando os números de 0 a 9. Dentro de um sistema eletrônico, isso é complicado por que a carga de cada dispositivo, seja transistor, seja válvula, deveria ser medida para verificar se que número ela estava representando. Os erros eram muito frequentes. Bastava que uma válvula estivesse fora da temperatura ideal para que os resultados das operações começassem a sair errado.  Von Neumann recomendou em sua arquitetura que os dados e instruções fossem agora armazenados em binário, facilitando a análise dos mesmos e reduzindo a quantidade de erros.</p></div>
<div class="paragraph"><p>Em 1952, o professor John von Neumann, da Univeridade de Princeton, Estados Unidos, apresentou um projeto inusitado para a arquitetura de um computador. Ele sugeriu que o computador fosse organizado em componentes, cada um executando apenas uma única tarefa e de forma muito mais organizada. Ele propôs que o computador fosse composto por (ver <a href="#fig_neumann">[fig_neumann]</a>):</p></div>
<div class="ulist"><ul>
<li>
<p>
Memória Principal: responsável por armazenar os programas a serem executados, assim como os dados a serem processados
</p>
</li>
<li>
<p>
Unidade Lógica e Aritmética (ULA): para realização das operações lógicas e aritméticas
</p>
</li>
<li>
<p>
Unidade de Controle: que, baseado nas instruções lidas da memória, enviaria sinais de controle para a ULA para que a mesma executasse as operações devidas
</p>
</li>
<li>
<p>
Unidade Central de Processamento (CPU): que agruparia a ULA e a Unidade de Controle
</p>
</li>
<li>
<p>
Unidade de Entrada e Saída: responsável pela comunicação com os periféricos do computador (teclado, monitor, memória externa etc.)
</p>
</li>
</ul></div>
<div class="imageblock" id="fig_neumann">
<div class="content">
<img src="images/fig_neumann.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 5. Estrutura da Máquina de von Neumann</div>
</div>
<div class="paragraph"><p>A Arquitetura de von Neumann deu tão certo que todos os fabricantes começaram a segui-la. Os computadores utilizados até hoje em dia seguem os preceitos básicos propostos por ele. Muitos avanços surgiram, melhorias foram feitas, mas até hoje os computadores são formados por Unidades de Controle, CPU, ULA, memória e Unidades de Entrada e Saída. John von Neumann deixou um legado para toda a humanidade.</p></div>
</div>
<div class="sect3">
<h4 id="_a_ibm">A IBM</h4>
<div class="paragraph"><p>A International Business Machines, ou apenas IBM, foi fundada em 1911 com o nome de Computing Tabulating Recording (CTR) e iniciou produzindo e comercializando calculadoras para empresas e empresários. Só em 1924 é que ela muda de nome para International Business Machines ou apenas IBM. Ela é uma das poucas empresas que sobreviveram a todos os avanços da computação e continua sendo uma potência mundial. Apenas em 1953 a IBM entra no mercado de computadores com o IBM 701, tendo sempre as grande organizações como alvos. Só muitos anos depois é que os computadores pessoais foram surgir. O IBM 701 trabalhava com cartões perfurados, ou seja, toda programação dele era feita através de uma perfuradora que marca buracos para representar o bit 1, e deixava ilesa uma área para representar o 0. O mesmo acontecia depois que os programas era lidos e processados. Uma folha de papel era perfurada pelo computador para representar o resultados das operações executadas. Não preciso nem dizer o que isso era trabalhoso!</p></div>
<div class="paragraph"><p>Em 1955 a IBM lança o IBM 702 que agora não fazia apenas cálculos científicos, mas também aplicações comerciais, visando deixar de ser um equipamento apenas para cientistas, mas também para empresários. Depois desses vários outros computadores foram lançados nas séries 700. Essas máquinas ainda utilizavam válvulas para armazenar os dados. Só em 1957 é que surge a Segunda Geração de computadores, com a utilização de transistores. Isso tornou os computadores mais leves, baratos, velozes e mais energicamente eficientes. Os primeiros computadores dessa geração foram o IBM 7000 e o PDP-1, da DEC, empresa que não existem mais.</p></div>
<div class="paragraph"><p>A IBM lança em 1964 o IBM série 360, substituindo os antigos computadores da série 7000. O IBM 360 inicia a primeira família de planejada de computadores. Isso significava que todos computadores seguintes da série 360 seriam compatíveis com os anteriores. Todos programas desenvolvidos ou adquiridos pelas empresas poderiam ser usados mesmo que a empresa substituísse os computadores pela geração mais nova. Isso tornou a IBM uma das empresas mais poderosas do mundo na época, com filiais e representantes em todos o continentes do planeta.</p></div>
</div>
<div class="sect3">
<h4 id="_as_gerações_dos_computadores">As gerações dos computadores</h4>
<div class="paragraph"><p>As gerações de computadores surgiram com a miniaturização dos transistores e sua integração em chips em escalas cada vez maiores. Podemos então ver as gerações dos computadores como:</p></div>
<div class="ulist"><ul>
<li>
<p>
1946 a 1957: computadores baseados em tubos de vácuo
</p>
</li>
<li>
<p>
1958 a 1964: surgimento dos transistores
</p>
</li>
<li>
<p>
1965: indústrias atingiram a integração de até 100 transistores num único chip
</p>
</li>
<li>
<p>
1971: chamada de Integração em Média Escala, com até 3000 transistores por chip
</p>
</li>
<li>
<p>
1971 a 1977: Integração em Larga Escala, com até 100.000 transistores por chip
</p>
</li>
<li>
<p>
1978 a 1991: Integração em Escala Muito Grande (VLSI), com até 100 milhões de transistores por chip
</p>
</li>
<li>
<p>
1991 até a atualidade: Integração Ultra-VLSI, com mais de 100 milhões de transistores por chip
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_memórias_de_semicondutores">Memórias de semicondutores</h4>
<div class="paragraph"><p>Em 1970, uma empresa chamada Fairchild desenvolveu pela primeira vez uma memória utilizando a mesma tecnologia utilizada para fabricar os processadores, os transistores. Isso possibilitou que memórias muito menores, mais rápidas e mais baratas fossem desenvolvidas. E melhor, elas poderiam ser inseridas muito próximas, e até dentro dos processadores, acompanhando sua miniaturização. E foi o que aconteceu. A medida que a tecnologia foi avançando e produzindo transistores cada vez menores, as memórias também foram encolhendo.</p></div>
<div class="paragraph"><p>Os processadores tornaram-se cada vez menores e mais velozes, mas infelizmente o avanço não ocorreu também com a velocidade das memórias, mas apenas com o seu tamanho. Isso até hoje é um problema. Armazenamentos rápidos são muito complexos de fabricar e, por consequência, caros. Isso vem limitando o avanço da velocidade dos computadores, mas sempre os cientistas vêm encontrando alternativas para manter Gordon Moore e todos nós muito orgulhosos.</p></div>
</div>
<div class="sect3">
<h4 id="_a_intel">A Intel</h4>
<div class="paragraph"><p>A Intel Corporation, ou simplesmente Intel, surgiu nos Estados Unidos em 1968, como uma empresa focada no projeto e fabricação de circuitos integrados. Ela foi fundada por Gordon Moore (o mesmo da Lei de Moore) e Robert Noyce. Ela era inicialmente uma concorrente da IBM, mas logo se tornaram parceiras. A Intel fabricava os processadores e memória, e a IBM fazia a composição deles com outros componentes para montar os computadores.</p></div>
<div class="paragraph"><p>Em 1971 a Intel lança seu primeiro processador, o 4004, que trabalhava com operações e dados de 4 bits. Foi uma revolução, pois todos componentes da CPU estavam num único chip. No ano seguinte eles lançam o 8008, já de 8 bits. Em 1974 é lançado o 8080, primeiro processador de propósito geral. Ou seja, com ela tanto era possível executar aplicações científicas, financeiras, gráficas e jogos. O mesmo princípio dos processadores atuais. Ele foi substituído pelo 8086 de 16 bit. O próximo foi o 80286 que já era capaz de trabalhar com uma memória de 16MBytes. O 80386 trabalhava com 32 bits e tinha suporte a multi-tarefas, ou seja, era finalmente possível executar mais de uma aplicação simultaneamente. Depois veio o 80486 com muito mais memória e bem mais rápido, além de um co-processador específico para aplicações matemáticas. A partir do 80286 as pessoas omitiam o 80 ao falar do processador, chamando-o apenas de 286, 386 e 486.</p></div>
<div class="paragraph"><p>Em seguida veio a geração Pentium, focando cada vez mais na execução de tarefas paralelas, adicionando várias unidades de processamento e armazenamento de dados dentro processador. Agora os processadores não teriam apenas uma ULA ou uma memória dentro do processador, mas várias delas. Hoje estamos na geração dos processadores multi-núcleos, ou multi-cores, que nada mais são do que vários processadores replicados dentro de um mesmo chip e coordenadores por uma unidade única.</p></div>
</div>
<div class="sect3">
<h4 id="_a_apple_e_a_microsoft">A Apple e a Microsoft</h4>
<div class="paragraph"><p>Em 1974 Steve Jobs e Steve Wosniak trabalhavam noites a fio para tentar, pela primeira vez, criar um computador que fosse voltado não a empresas, mas a pessoas também. Seria a ideia de um computador pessoal. Eles compraram todos componentes necessários para montar um computador, fizeram várias improvisações e inovações, acoplaram uma TV e um teclado. Wosniak, um gênio da eletrônica e programação, desenvolveu o software para controlar o computador e ainda alguns aplicativos, como uma planilha de cálculos e alguns jogos. Assim que o protótipo ficou prontos, Steve Jobs, eximiu negociador e vendedor, colocou o computador na mala de seu carro e foi visitar várias empresas para conseguir algum apoio financeiro para poder fabricar o produto em escalas maiores. Foi até na IBM, mas ouviu deles que o mercado de computadores pessoais não era promissor e o negócio deles era a produção de grandes computadores para empresas.</p></div>
<div class="paragraph"><p>Assim que conseguiram o primeiro cliente, em 1976, Jobs e Wosniak fundaram a Apple e lançaram o Apple I. Um produto mais maduro e melhor acabado. Jobs sempre gostava de produtos de design diferenciado, que fossem não apenas eficientes, mas bonitos e, principalmente, fáceis de usar. Suas apresentações anuais de lançamento de novos produtos eram sempre aguardados com grande expectativa e especulações.</p></div>
<div class="paragraph"><p>A IBM inicialmente também desenvolvia o Sistema Operacional e os programas que iriam ser executados por suas máquinas. Logo ela percebeu que poderia fazer parcerias com outras empresas e agregar ainda mais valor aos seus produtos. Foi aí que surgiu a Microsoft, liderada pelo seu fundador, Bill Gates, com o seu sistema operacionais MS-DOS. Não demorou muito para que todos computadores lançados pela IBM trouxessem também o MS-DOS integrados e eles. Depois surgiram as evoluções do MS-DOS, o Windows e suas várias gerações. A Microsoft se beneficiou bastante dessa parceria, já que todos a grande maioria dos computadores do mundo executavam seu sistema, as pessoas teriam que aprender e se familiarizar com seu sistema operacional. As empresas de desenvolvimento de aplicativos e jogos tinham que fazê-los compatíveis com o MS-DOS e Windows e foi aí que a Microsoft se tornou uma das líderes do mercado e, por muitos anos, a mais rica empresa do mundo.</p></div>
<div class="paragraph"><p>Steve Jobs sempre acusou o Bill Gates de ter copiado dele o código principal para o funcionamento do MS-DOS. Gates nunca negou. Eles sempre trocavam acusações e isso gerou muito assunto para a impressa e fanáticos por tecnologia. A verdade é que a Microsoft cresceu bastante e a Apple passou por vários apertos. Só no ano 2000, quando Jobs retornou à Apple depois de ter sido expulso da própria empresa que ele fundou, foi que as coisas melhoraram para a Apple. Eles lançaram produtos em outras linhas que não fossem computadores pessoais, como o iPod para ouvir música e o telefone celular iPhone. A Apple passou então a dominar o mercado de música online com sua loja de músicas, iTunes e o iPhone é o Smartphone mais vendido do mundo.</p></div>
<div class="paragraph"><p>Steve Jobs seguia a filosofia não de fazer clientes, mas de criar fãs. E deu certo. Hoje há vários ``Apple Maniamos” que compram seus produtos antes mesmo deles serem apresentados ao público. Nos dias em que esse livro está sendo escrito, a Apple ultrapassou a IBM e a Microsoft em valor, e é a empresa mais valiosa do mundo.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_recapitulando">Recapitulando</h3>
<div class="paragraph"><p>Ao final desse capítulo vimos o que é a arquitetura de um computador e porque é tão importante estudá-la. Vimos que o transistor é o dispositivo básico para todo o funcionamento de um computador. Estudar seu funcionamento e sua evolução, é estudar a própria Ciência da Computação e a eletrônica digital. Depois de seu surgimento, os computadores foram possíveis e avançaram a medida que eles encolhiam de tamanho e aumentavam de velocidade, consumindo menos energia. Com a evolução dos computadores, cada vez mais rápidos, menores e mais baratos, toda a humanidade avançou na mesma velocidade. No próximo capítulo vamos estudar mais a fundo como os processadores funcionam. Como os programas são executados e o que é feito nos dias de hoje para que eles sejam cada vez mais eficientes.</p></div>
</div>
<div class="sect2">
<h3 id="_atividades">Atividades</h3>
<div class="ulist"><ul>
<li>
<p>
Quais as quatro funções básicas que todos os computadores executam? Dê um exemplo de operação de cada uma delas.
</p>
</li>
<li>
<p>
Quais os elementos básicos de um computador e quais as funcionalidades de cada um deles?
</p>
</li>
<li>
<p>
Quais as diferenças entre um sinal analógico e um digital? Apresente os pontos fortes e fracos de cada um deles. Na sua opinião, qual dos dois sinais apresentam maior qualidade?
</p>
</li>
<li>
<p>
Caracterize o que é uma Máquina de von Neumann
</p>
</li>
<li>
<p>
O que são transistores? Quais as vantagens na concepção de computadores com o surgimento dos transistores?
</p>
</li>
<li>
<p>
Por que quantos menores os transistores, mais velozes os computadores? Há desvantagens nessa miniaturização das máquinas? Quais?
</p>
</li>
<li>
<p>
O que diz a Lei de Moore? Em sua opinião, há um limite para esse crescimento? Onde vamos chegar?
</p>
</li>
<li>
<p>
Que outras técnicas podem ser utilizadas para aumento do desempenho dos processadores que não pela redução do tamanho dos transistores? Explique cada uma delas.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unidade_central_de_processamento_cpu">Unidade Central de Processamento (CPU)</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="title">Objetivos do capítulo</div>
<div class="content">
<div class="paragraph"><p>Ao final deste capítulo você deverá ser capaz de:</p></div>
<div class="ulist"><ul>
<li>
<p>
objetivo 1
</p>
</li>
<li>
<p>
objetivo 2
</p>
</li>
<li>
<p>
objetivo N
</p>
</li>
</ul></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Nesse capítulo vamos estudar a parte mais importante de um computador, que é a Unidade Central de Processamento, ou UCP, ou, do inglês, CPU.
A CPU é responsável não apenas por executar os programas contidos na memória, mas também de controlar todos os dispositivos de entrada e saída.
Seu avanço ao longo dos anos tem permitido que programas fossem executados cada vez mais rapidamente.
Hoje temos processadores de vários núcleos capazes de executar várias atividades ao mesmo tempo.
São esses processadores e funcionalidades que iremos estudar nesse capítulo.</p></div>
<div class="sect2">
<h3 id="_o_que_é_um_programa">O que é um programa?</h3>
<div class="paragraph"><p>Nesse momento, você não apenas deve saber o que é um programa, como já deve ter até já escrito seus próprios programas e entendido um pouco como o computador funciona.
Os programas são sequências finitas de passos que foram definidas por um programador para alcançar um objetivo específico.
Cada passo desse programa é chamado de instrução.
Não necessariamente, uma instrução escrito em uma linguagem de alto nível, como C, Java, Python, por exemplo, é diretamente transformada em uma instrução de máquina e armazenada em memória para execução da CPU.
Na verdade, geralmente, uma instrução de uma linguagem de alto nível embute vários comandos e ações a serem executadas pela CPU.
Essa é a principal razão da criação dessas linguagens de alto nível.
O programador deve ter o menor trabalho possível ao escrever um programa.
Ele deve se preocupar com o problema que está tentando solucionar, e em memorizar dezenas de comandos de uma linguagem de máquina extensa e repleta de detalhes.</p></div>
<div class="paragraph"><p>Após compilado, o programada de linguagem de alto nível é transformado em um programa apenas com instruções de máquina.
Cada instrução de máquina contém apenas uma única operação a ser realizada pela CPU.
Para ser executado, esse programa deve ser transferido para a Memória Principal.
No princípio, um Operador de Máquina, copiada todas instruções para a memória de maneira quase que manual.
Hoje em dia essa operação é realizada pelo Sistema Operacional (Windows, Linux etc.).
Assim que um usuário clica com o mouse, ou pressiona a tecla Enter do teclado solicitando que um determinado programa execute, o Sistema Operacional copia o programa para a memória e solicita que a CPU o execute.</p></div>
<div class="paragraph"><p>Não podemos esquecer que a memória do computador apenas armazena números binários.
Então, podemos dizer que um programa em linguagem de máquina é formado por instruções em binário.
A cada instrução trazida da memória, a CPU lê seu código binário de operação para saber do que se trata, e inicia o processo de execução.
Dependendo da operação, que pode ser de movimentação de dados, uma operação lógica, ou aritmética, ou uma operação de armazenamento de dados, a CPU envia ordens para que os outros dispositivos do computador atuem de forma a completar a operação.
Essas ordens são enviadas através de pulsos elétricos passados por fios dentro do computador. Esses fios são chamados de <strong>Barramento de Controle</strong>.</p></div>
<div class="sect3">
<h4 id="_software_x_hardware">Software X Hardware</h4>
<div class="paragraph"><p>O computador é composto por dois elementos, o software e o hardware.
Tanto o hardware quando o software foram escritos por um programador, ou engenheiro, para se resolver um determinado problema.
O início é sempre o mesmo. O profissional se depara com um problema e projeta uma solução algorítmica para ele.
A diferença está na concepção. O hardware é concebido em chip, utilizando transistores interconectados.
Uma vez elaborado, o hardware não pode mais ser modificado. Ele é uma solução rígida (do inglês, Hard) para o problema.
Já o software é elaborado para ser armazenado numa memória e ser executado com um processador de propósito geral.
Ele é uma solução flexível (do inglês, Soft) para o problema, já que o programador pode, a cada momento, modificar seu programa afim de torná-lo cada vez melhor.</p></div>
<div class="paragraph"><p>Soluções em software são sempre mais lentas do que soluções equivalentes em hardware.
Isso porque para executar um programa, cada instrução deve antes ser armazenada em memória, transferidas para a CPU (lembre-se que memórias são muito mais lentas do que CPUs) e, só então, ser executada pela CPU.
Já as soluções em hardware não utilizam instruções, elas executam as operações diretamente.</p></div>
<div class="paragraph"><p>Por outro lado, as soluções em software ganham em flexibilidade, já que os programas podem ser facilmente modificados.
Já as soluções em hardware, não.
Uma vez concebido, um hardware não pode mais ser modificado, ele deve ser descartado para dar lugar a uma versão mais nova.
Isso torna projetos em hardware muito mais caros.</p></div>
<div class="paragraph"><p>Para entender melhor, podemos citar alguns exemplos de implementações em hardware comumente utilizadas.
Todas são escolhidas devido ao seu caráter de pouca necessidade de modificação, mas muito demanda por alto desempenho.
Por exemplo, chips de criptografia para celulares (geralmente smartphones), processadores aritméticos para acelerar o cálculos, aceleradores gráficos para gerar gráficos mais rápidos, alguns chips para fazer edições rápidas em fotos, geralmente acoplados às câmeras digitais. As implementações são feitas em software quando a demanda por desempenho não é tanta, ao mesmo tempo em que as atualizações são frequentes, como os Sistemas Operacionais, os jogos e aplicativos em geral.</p></div>
<div class="paragraph"><p>Apesar de não ser tão rápida quanto gostaríamos, a CPU é uma solução muito boa por permitir a execução de, praticamente, qualquer tipo de programa, se tornando uma máquina de propósito geral.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_estrutura_de_uma_cpu">Estrutura de uma CPU</h3>
<div class="paragraph"><p>Toda CPU é formada por duas unidades, como podem ser vistas na <a href="#fig_CPU">[fig_CPU]</a>:</p></div>
<div class="ulist"><ul>
<li>
<p>
Unidade de Controle (UC)
</p>
</li>
<li>
<p>
Unidade de Ciclo de Dados (UCD)
</p>
</li>
</ul></div>
<div class="imageblock" id="fig_CPU">
<div class="content">
<img src="images/fig_CPU.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 6. Estrutura de uma CPU</div>
</div>
<div class="paragraph"><p>A Unidade de Controle é responsável por receber instruções pelo Barramento de Instruções. As instruções vêem da memória de acordo com o endereço enviado pela UC para a memória através do Barramento de Endereço das Instruções (à esquerda da UC na <a href="#fig_CPU">[fig_CPU]</a>).
Já Unidade de Ciclo de Dados, como o próprio nome deixa entender, é responsável por tratar os dados propriamente ditos.
A Unidade de Controle não executa as instruções.
Ela as lê, decodifica e passa os comandos para a UCD determinando como as instruções devem ser executadas e com quais dados.
Baseada nessas comandos, a UCD pode ir buscar os dados necessários na memória, executa as devidas operações e envia o resultado de volta para a memória para ser armazenado.
Tudo controlado de acordo com os comandos internos enviados pela Unidade de Controle, que por sua vez se baseia na instrução decodificada.
Os dados lidos, ou enviados para a memória, são transmitidos através do Barramento de Dados.
Os endereços são enviados para a memória através do Barramento de Endereço.</p></div>
<div class="paragraph"><p>Tudo isso é controlado por um sinal síncrono de relógio (clock, do inglês).
A cada batida do relógio a unidade sabe que deve executar um passo, passar os dados para quem deve, e se preparar para o próximo passo.
Quanto mais rápido é o relógio mais operações por segundo o processador consegue executar e mais rápido pode se tornar.
A velocidade do relógio é medida em frequência, utilizando a unidade Herz (abreviatura é Hz).
Um Herz significa um passo por segundo.
Os processadores atuais trabalham na faixa dos poucos GHz (leia-se Giga Herz), entre 1 GHz e 5 GHz.
Um Giga Herz significa um bilhão de passos por segundo.
É por isso que os computadores são tão incríveis.
Eles não executam operações extraordinárias. Pelo contrário.
Executam operações extremamente simples, como somas, subtrações e multiplicações, mas fazem isso numa velocidade incrível.</p></div>
<div class="sect3">
<h4 id="_os_papéis_dos_barramentos_e_da_memória">Os papéis dos barramentos e da memória</h4>
<div class="paragraph"><p>Saindo um pouco de dentro da CPU, podemos enxergar os barramentos e a Memória Principal, como é apresentado na <a href="#fig_CPU_com_barramento">[fig_CPU_com_barramento]</a>.
Para facilitar a visualização, os Barramentos de Dados e de Endereço são apresentados replicados, tanto do lado esquerdo, quanto do direito da figura.</p></div>
<div class="imageblock" id="fig_CPU_com_barramento">
<div class="content">
<img src="images/fig_CPU_com_barramento.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 7. Estrutura de uma CPU com barramentos</div>
</div>
<div class="paragraph"><p>A comunicação da Unidade de Controle e da Unidade de Ciclo de Dados é feita sempre com a Memória Principal através dos barramentos.
Os endereços são transmitidos sempre via Barramento de Endereços para a memória, sempre de forma unidirecional da CPU para a memória.
Quando as instruções são transmitidas da memória para a Unidade de Controle, elas utilizam o Barramento de Dados.
Isso porque as instruções são tratadas pela memória como um conteúdo como um outro qualquer.
Ela não faz distinção entre dados e instruções.
O mesmo Barramento de Dados é utilizado pela Unidade de Ciclo de Dados para receber os operando das operações a serem realizadas e para enviar os resultados de volta para a memória.</p></div>
<div class="paragraph"><p>Fica claro então a importância da Memória Principal.
Todo e qualquer programa só poderá ser executado a partir dela. Quando você, por exemplo, deseja executar um programa de um pendrive conectado pela USB do computador, ele antes precisa ser copiado para a Memória Principal.
Só então ele será executado.
A memória precisa ser grande o bastante para armazenar a maior quantidade possível de programas, e também precisa ser rápida o suficiente para buscar os dados e enviá-los o mais rapidamente possível à CPU, e também salvá-los no menor tempo possível.
A velocidade das memórias é determinada essencialmente pela tecnologia de transistores utilizada.
Essa tecnologia é relacionada ao preço. Quanto mais rápidas, mais caras elas são.</p></div>
</div>
<div class="sect3">
<h4 id="_os_registradores">Os registradores</h4>
<div class="paragraph"><p>Os registradores são memórias elaboradas com o mínimo de transistores possível, utilizando o que há de mais moderno em tecnologia de armazenamento.
Elas são as memórias mais rápidas que podem ser construídas e por isso são também as mais caras.
Por essa razão, elas aparecem numa quantidade muito pequena em um computador, na casa de alguns Kilo Bytes.
Eles podem ser divididos em dois grupos.
Os registradores de propósito geral, e os de propósito específico.
Como o próprio nome diz, os primeiros podem ser utilizados pelos programas para quaisquer objetivos, já os segundos são específicos para algumas tarefas.
Por exemplo, há um registrador na CPU para controlar se o processador deve continuar em execução, ou entrar em modo de espera por nova ordem.
Se esse registrador receber um valor diferente de zero, o processador entrará em modo de espera, até que receba a ordem de modificar esse valor.
Na <a href="#fig_arq_detalhada">[fig_arq_detalhada]</a> os registradores de propósito específico apresentados são:</p></div>
<div class="ulist"><ul>
<li>
<p>
Program Counter (PC): Contador de Programas
</p>
</li>
<li>
<p>
Instruction Register (IR): Registrador de Instrução
</p>
</li>
<li>
<p>
Memory Address Register (MAR): Registrador de Endereço
</p>
</li>
<li>
<p>
Memory Buffer Register (MBR): Registrador de Dados
</p>
</li>
</ul></div>
<div class="imageblock" id="fig_arq_detalhada">
<div class="content">
<img src="images/fig_arq_detalhada.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 8. Estrutura de uma CPU com registradores</div>
</div>
<div class="paragraph"><p>O PC contém o endereço de memória que será utilizado para buscar a próxima instrução a ser executada pela CPU.
Antes de executar qualquer instrução, a CPU envia o conteúdo de PC para a memória através do Barramento de Endereço, a memória envia o conteúdo da memória nesse endereço através do Barramento de Dados.
Esse conteúdo é então armazenado no IR.
Já o IR, que recebeu a instrução que veio da memória, tem o objetivo de guardar a instrução e passá-la para a Unidade de Controle, que é quem vai lê-la e tomar as decisões necessárias para para que ela seja executada pela Unidade de Ciclo de Dados.
Por se tratarem do processo de busca de instruções, o PC e o IR ficam instalados na Unidade de Controle.
O PC possui conexão direta com o Barramento de Endereços, e o IR com o Barramento de Instruções.</p></div>
<div class="paragraph"><p>Com relação ao MAR e ao MBR, eles possuem funções análogas ao PC e IR, respectivamente, mas referentes a dados e não a instruções.
Quando uma operação precisa ser realizada com algum dado que está na memória (e não em um registrador), o endereço desse dado é passado para o MAR.
A CPU então passa o conteúdo de MAR para a memória através do Barramento de Endereço, que retornará o conteúdo da memória nesse endereço através do Barramento de Dados.
O conteúdo trazido pela memória será armazenado em MBR.
Só então o dado poderá ser utilizado para o processamento inicialmente planejado.
O MBR e MAR possuem, respectivamente, conexões diretas com os Barramentos de Dados e de Endereços. Ambos são situados na Unidade de Ciclo de Dados, por serem utilizados nas fases de processamento das instruções.</p></div>
<div class="paragraph"><p>O tamanho e quantidade dos registradores de uma CPU é uma das principais decisões de projeto.
Se forem grandes demais, ou em quantidade maior do que a necessária, podem resultar em desperdício e aumento desnecessário no preço do processador.
Já se forem pequenos, ou em pouca quantidade, com certeza vão tornar o computador muito mais lento do que o desejado.
Encontrar o tamanho e quantidade ideias é trabalhoso e geralmente é feito através de simuladores e de muito testes e anos de experiência.</p></div>
<div class="paragraph"><p>Os registradores de propósito geral são utilizados para guardar as variáveis dos programas. Como eles estão presentes em quantidades muito pequenas, são poucas as variáveis que ficam armazenadas em registradores. As demais ficam na Memória Principal. Quando uma operação precisa ser realizada e seus dados estão nos Registradores de Propósito Geral, a CPU não precisa buscá-los na memória e o processamento torna-se muito mais rápido.</p></div>
<div class="paragraph"><div class="title">NOTE</div><p>Lembre-se que as memórias são muito mais lentas do que os processadores!</p></div>
<div class="paragraph"><p>A CPU tenta ao máximo manter as variáveis mais utilizadas nos registradores. Ela faz isso guardando aquelas mais usadas nas últimas operações. Nem sempre isso funciona, mas no geral, é a melhor solução.</p></div>
<div class="paragraph"><div class="title">NOTE</div><p>Faça suas variáveis mais importantes serem bastante utilizadas.
Usando-as em repetições, por exemplo.
Isso aumentará as chances delas serem armazenadas em registradores, podendo acelerar a execução dos seus programas.</p></div>
</div>
<div class="sect3">
<h4 id="_unidade_lógica_e_aritmética_ula">Unidade Lógica e Aritmética (ULA)</h4>
<div class="paragraph"><p>A Unidade Lógica e Aritmética, ou ULA, se assemelha muito com uma calculadora convencional.
Ela executa operações lógicas e aritméticas.
As ULAs modernas executam operações tanto com inteiros, como com números reais.
A ULA recebe como entrada dois diferentes dados que são trazidos para ela dos registradores (de propósito geral, ou específicos) (veja a <a href="#fig_arq_detalhada">[fig_arq_detalhada]</a>).
Quem decide que registradores passarão seus dados para a ULA é a Unidade de Controle baseada instrução que está sendo executada.
A Unidade de Controle também envia para a ULA qual operação será realizada (soma, multiplicação, divisão, AND, OR etc.).
Assim que isso é feito, a ULA executa a operação e gera um resultado na sua saída.
Esse resultado também é passado para um registrador escolhido pela Unidade de Controle, baseando-se na instrução em execução.</p></div>
</div>
<div class="sect3">
<h4 id="_unidade_de_controle_uc">Unidade de Controle (UC)</h4>
<div class="paragraph"><p>A Unidade de Controle, ao receber a instrução que está armazenada em IR, a decodifica e envia os sinais de controle para onde for necessário.
Decodificar nada mais é do que ler um código em binário e interpretar a operação relativa a esse código.
Dependendo da operação, os sinais de controle podem ser internos, por exemplo, para a ULA executar uma soma, ou para o conteúdo de um registrador ser transferido para a ULA.
Ou pode ser externo, para um dispositivo de entrada e saída, por exemplo, ou mesmo para a Memória Principal.
Tudo isso depende da instrução a ser executada.</p></div>
<div class="paragraph"><p>Na próxima seção será apresentada a execução de instruções em mais detalhes, o que facilitará o entendimento do funcionamento das CPUs.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_instrução">Ciclo de Instrução</h3>
<div class="paragraph"><p>Toda CPU trabalha em dois ciclos principais, o Ciclo de Busca e o Ciclo de Execução, como pode ser visto na <a href="#fig_ciclo_instrucao">[fig_ciclo_instrucao]</a>.
Assim que o computador é iniciado, a CPU entra no Ciclo de Busca, em seguida passa para o Ciclo de Execução e depois volta para o Ciclo de Busca.
Ela continua nesse processo até que precise ser desligada, saindo do Ciclo de Execução para o estado final.</p></div>
<div class="imageblock" id="fig_ciclo_instrucao">
<div class="content">
<img src="images/fig_ciclo_instrucao.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 9. Ciclo de Instrução</div>
</div>
<div class="paragraph"><p>Durante o Ciclo de Busca, é a Unidade de Controle que atua.
Uma nova instrução é busca da Memória para que possa ser decodificada.
Nessa fase os registradores PC e IR são utilizados, como apresentados na seção anterior.
O PC é logo lido para se saber que instrução será executada, essa instrução é trazida para o IR e, finalmente, é decodificada pela Unidade de Controle.
Assim que esse processo termina, caso a instrução não diga respeito à um laço, ou à uma repetição, o conteúdo de PC é incrementado. Ou seja, PC recebe PC + 1.
Assim, no próximo Ciclo de Busca a instrução do endereço seguinte será carregada da memória e executada.
Esse comportamento garante a característica de execução sequencial dos programas.</p></div>
<div class="paragraph"><p>No passo seguinte a CPU entra em Ciclo de Execução.
Nessa etapa atua a Unidade de Ciclo de Dados.
Agora a Unidade de Controle já sabe exatamente que operação será executada, com quais dados e o que fazer com o resultado.
Essa informação é passada para a ULA e os registradores envolvidos.
Durante o Ciclo de Execução há cinco possíveis tipos de operação que podem ser executadas:</p></div>
<div class="ulist"><ul>
<li>
<p>
Processador e memória: trata simplesmente da transferência de dados entre CPU e memória principal ;
</p>
</li>
<li>
<p>
Processador e Entrada e Saída: diz respeito à transferência de dados entre a CPU e um dispositivo de Entrada e Saída, como teclado, mouse, monitor, rede, impressora etc.;
</p>
</li>
<li>
<p>
Processamento de Dados: são operações simplesmente de processamento dos dados, como operação aritmética ou lógica sobre os registradores da CPU;
</p>
</li>
<li>
<p>
Controle: são instruções que servem para controlar os dispositivos do computador, como para ligar um periférico, iniciar uma operação do disco rígido, ou transferir um dado que acabou de chegar pela Internet para a Memória Principal;
</p>
</li>
<li>
<p>
Operações compostas: são operações que combinam uma ou mais intrusões das outras em uma mesma operação.
</p>
</li>
</ul></div>
<div class="sect3">
<h4 id="_busca_de_dados">Busca de Dados</h4>
<div class="paragraph"><p>Em operações entre Processador e Memória, é necessário que dados sejam trazidos da memória para servirem de entrada para a ULA, e/ou o resultado seja levado para armazenamento na memória no final da execução.
Para isso acontecer, é executada uma Busca de Dados. Isso é determinado durante a decodificarão da instrução, no ciclo de Busca de Instrução.
Isso acontece quando um dos parâmetros de uma operação aritmética é um endereço de memória, e não um valor diretamente, nem um registrador.
Para isso, parte do conteúdo de IR é transferido para o MAR. Essa parte é justamente o endereço do parâmetro da instrução.
Em seguida a Unidade do Controle requisita à memória uma leitura.
Assim, o endereço, agora em MAR, é passado para a memória e o conteúdo lido da memória é passado para o MBR.
Agora o conteúdo é transferido para a ULA para que a operação seja executada (lógica ou aritmética).</p></div>
<div class="paragraph"><p>Se a instrução tiver dois ou mais parâmetros de memória, serão necessárias outras Buscas de Dados.
Como a memória é sempre mais lenta do que a CPU, instruções que necessitam Buscas de Dados são muito mais lentas do que instruções de Processamento de Dados.</p></div>
<div class="paragraph"><p>Perceba que cada instrução pode exigir mais tempo de execução do que outras. Isso depende de quantos acessos à memória ela exigirá.
Quanto mais acessos à memória, mais lenta a instrução.
O ideal é sempre usar registradores.
Mas nem sempre é possível utilizar registradores.
Eles estão sempre em poucas quantidades e em menores tamanhos. Principalmente por serem caros.
O que os computadores sempre tentam fazer é passar os dados da memória para os registradores assim que puderem, para que as próximas instruções sejam aceleradas.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_interrupções">Interrupções</h3>
<div class="paragraph"><p>Além do ciclo básico de intrusão apresentado anteriormente, a CPU pode ainda executar outro tipo de tarefa.
Ela diz respeito ao processamento de pedidos oriundos dos dispositivos de Entrada e Saída.
Como o Ciclo de Instrução da CPU que vimos até o momento é fechado, ou seja, a CPU sempre fica em estado de repetição até que seja desligada, ela não pode atender a nenhum evento externo que não seja a execução de um programa.
Por exemplo, quando um usuário pressiona uma tecla do teclado, ou faz um movimento com o mouse, ou mesmo, quando uma mensagem chega pela Internet através da placa de rede.
O que a CPU deve fazer?
Se ela estiver em um Ciclo de Instrução fechado como mostrado anteriormente, nada.
Ela precisa parar o que está fazendo para atender ao evento ocorrido e, só então, voltar ao Ciclo de Instruções.
Esse processo de parar o Ciclo de Instrução para atender a um evento externo é chamado de Interrupção.</p></div>
<div class="paragraph"><p>O Ciclo de Instrução pode agora ser visto modificado na <a href="#fig_ciclo_com_interrupcao">[fig_ciclo_com_interrupcao]</a> para atender às Interrupções.
Todas interrupções são recebidas e armazenadas internamente por um dispositivo chamado Gerenciador de Interrupções.
Esse dispositivo é um chip, semelhante à uma CPU, mas bem mais simples.</p></div>
<div class="imageblock" id="fig_ciclo_com_interrupcao">
<div class="content">
<img src="images/fig_ciclo_com_interrupcao.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 10. Ciclo de Instruções com interrupções</div>
</div>
<div class="paragraph"><p>Na maioria dos computadores eles vêm soldados na Placa-Mãe, mas podem também vir dentro do chip da CPU.
Toda interrupção possui um código de identificação. Sempre que uma nova interrupção chega nesse gerenciador, ele armazena esse código em sua memória e manda um sinal para CPU através do Barramento e Controle.
Durante seu Ciclo de Instrução, sempre que uma instrução é executada, antes de voltar para o Ciclo de Busca, a CPU chega de algum sinal de interrupção foi enviado pelo Gerenciador de Interrupção.</p></div>
<div class="paragraph"><p>Quando não há uma interrupção, a execução volta ao Ciclo de Busca e o programa em execução continua a ser executado.
Mas se houver uma interrupção, a CPU agora vai parar a execução do programa atual para atender a interrupção.
Por exemplo, vamos super que o usuário pressionou uma tecla do teclado.
O código armazenado pelo Gerenciador de Interrupção indica que a interrupção veio do teclado.
A CPU para sua execução do programa anterior e vai iniciar a execução de um programa especial, o Tratador de Interrupção.
O código do dispositivo (aqui seria o teclado) serve para a CPU saber o endereço do Tratador de Interrupção ela vai buscar da memória.
Então, ao sair do Checagem de Interrupção, a CPU muda o endereço do PC para o endereço do Tratador de Instrução.
Assim, no Ciclo de Busca a próxima instrução a ser trazida da memória e posteriormente executada será a do tratador do teclado.</p></div>
<div class="paragraph"><p>Cada tipo de interrupção precisa de um tratamento específico a ser feito. No caso do teclado, o tratador vai checar que tecla foi pressionada.
Isso é feito através de uma leitura à memória do teclado (sim, todos dispositivos possuem uma pequena memória) para saber que tecla foi pressionada.
Dependendo da tecla, uma operação diferente será executada.
Geralmente, a CPU adiciona o código da tecla pressionada num endereço específico de memória. Cada programa, lendo essa informação, tomará sua própria decisão sobre o que deve ser feito.
O que acontece é que apenas o programa ativo no momento, vai ler esse conteúdo, executar a ação da tecla e limpar essa área de memória.
Se o programa for um editor de texto, por exemplo, o código pode representar escrever a letra pressionada na posição atual do cursor dentro do texto.</p></div>
<div class="paragraph"><p>Quando esse processo encerra, o tratamento é encerrado, e a CPU deve voltar a execução do programa que havia sido interrompido.
Isso só é possível porque, antes de passar a execução do Tratador de Interrupção, a CPU salva os conteúdos de todos os registradores da CPU (inclusive o PC e o IR).
Então, antes de devolver a execução para o programa, CPU restaura todos os valores dos registradores antes salvos.
Dessa forma, o programa retoma exatamente do ponto em que parou.</p></div>
<div class="paragraph"><p>As interrupções também ocorrem se o próprio programa em execução executar uma operação ilegal.
Isso é feito para evitar que a CPU entre em erro.
Por exemplo, se um programa tentar acessar uma área da memória que é proibida para ele, como a área de outro programa ou do Sistema Operacional.
Nesse caso, o programa é interrompido e não volta mais a executar, ele é finalizado e a execução é devolvida ao Sistema Operacional.
Algo semelhante ocorre em caso de defeitos em alguns dispositivos.
Por exemplo, se um programa estiver lendo um arquivo que está em um pendrive, e esse pendrive é removido subitamente, uma interrupção é lançada e o programa é encerrado, já que ele não faz mais sentido estar em execução.</p></div>
</div>
<div class="sect2">
<h3 id="_sobre_o_desempenho">Sobre o desempenho</h3>
<div class="paragraph"><p>É possível agora perceber que o desempenho das CPUs depende de muito outros fatores além da velocidade do seu clock.
O computador precisa ter memórias rápidas para reduzir o tempo dos Ciclos de Busca, precisam de mais registradores para usar menos a memória e também que poucas interrupções ocorram.
Cada vez que uma interrupção ocorre, o programa deve ser interrompido e a chamada deve ser atendida.
Isso vai atrasar demais o tempo de execução dos programas, dando a impressão de baixo desempenho.</p></div>
<div class="paragraph"><p>Basicamente, há dois tipos programas, os orientados à CPU e os orientados a Entrada e Saída. Na <a href="#fig_entrada_saida">[fig_entrada_saida]</a> o comportamento dos primeiros é mostrado na parte a) e o dos segundos na parte b).</p></div>
<div class="imageblock" id="fig_entrada_saida">
<div class="content">
<img src="images/fig_entrada_saida.jpg" alt="scaledwidth=“30%"" />
</div>
<div class="title">Figura 11. Execução com várias interrupções</div>
</div>
<div class="paragraph"><p>Quando um programa é orientado à CPU, há momentos longos de processamento de CPU e curtos momentos de espera por um evento de Entrada e Saída. É o exemplo de programas que fazem muitos cálculos matemáticos, como ferramentas de simulação, projetos de engenharia, computação gráfica e planilhas de cálculos. Inicialmente os dados de entrada são passados por um dispositivo de entrada, há longos momentos de cálculos e depois os resultados são passados para um dispositivo de entrada e saída.</p></div>
<div class="paragraph"><p>Já nos programas orientados à Entrada e Saída (b), são aqueles chamados também de interativos. Há muitos momentos de interação e uso de dispositivos de Entrada e Saída, e poucos momentos de uso de CPU. Como é o caso de programas que usam muito de mouse e teclado, como os jogos e a própria navegação na internet.</p></div>
<div class="paragraph"><p>O que temos que ter em mente é que o desempenho de um computador está muito ligado ao perfil de cada usuário. Os Sistemas Operacionais são os responsáveis por escolher que tarefa colocar para executar a cada momento e por quanto tempo ela deve executar até que uma nova tarefa entre em execução. Assim, o papel do Sistema Operacional também é fundamental e determinante no desempenho do sistema. O que ele tenta fazer no máximo que pode, é tentar ocupar os tempos de espera de um programa com a execução de outro. Tarefa nada fácil!</p></div>
</div>
<div class="sect2">
<h3 id="_o_que_está_por_vir">O que está por vir</h3>
<div class="paragraph"><p>Até o momento vimos como um processador básico trabalha. Nas próximas seções desse capítulo vamos ver como o desempenho pode ser ainda mais aumentando adicionando técnicas avançadas de execução paralela e de técnicas de análise de programas.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-02-17 22:58:57 BRT
</div>
</div>
</body>
</html>
